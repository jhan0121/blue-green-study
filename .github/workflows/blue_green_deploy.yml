name: Blue-Green Deployment Pipeline

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]
  workflow_dispatch:
    inputs:
      environment:
        description: 'Target environment (auto/blue/green)'
        required: false
        default: 'auto'
        type: choice
        options:
          - auto
          - blue
          - green
      force_deploy:
        description: 'Force deployment even if tests fail'
        required: false
        default: false
        type: boolean

env:
  MYSQL_ROOT_PASSWORD: rootpass
  MYSQL_DATABASE: bluegreen
  MYSQL_USER: app_user
  MYSQL_PASSWORD: app_pass
  BUILD_NUMBER: ${{ github.run_number }}

jobs:
  test:
    name: üß™ Test Application
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up JDK 21
        uses: actions/setup-java@v4
        with:
          java-version: '21'
          distribution: 'corretto'

      - name: Cache Gradle packages
        uses: actions/cache@v3
        with:
          path: |
            ~/.gradle/caches
            ~/.gradle/wrapper
          key: ${{ runner.os }}-gradle-${{ hashFiles('**/*.gradle*', '**/gradle-wrapper.properties') }}
          restore-keys: |
            ${{ runner.os }}-gradle-

      - name: Make gradlew executable
        run: chmod +x bluegreen/gradlew

      - name: Run tests
        working-directory: bluegreen
        run: ./gradlew test

      - name: Build application
        working-directory: bluegreen
        run: ./gradlew clean build

      - name: Upload build artifacts
        uses: actions/upload-artifact@v4
        with:
          name: jar-artifact
          path: bluegreen/build/libs/*.jar
          retention-days: 7

  deploy:
    name: üöÄ Deploy to Production
    runs-on: self-hosted
    needs: test
    if: github.ref == 'refs/heads/main' && (success() || github.event.inputs.force_deploy == 'true')

    outputs:
      current_env: ${{ steps.detect.outputs.current }}
      target_env: ${{ steps.detect.outputs.target }}
      deploy_success: ${{ steps.deploy_result.outputs.success }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Download build artifacts
        uses: actions/download-artifact@v4
        with:
          name: jar-artifact
          path: bluegreen/build/libs/

      - name: Set up environment variables
        run: |
          # .env ÌååÏùº ÏÑ§Ï†ï ÌôïÏù∏ Î∞è ÏÉùÏÑ±
          if [ ! -f .env ]; then
            echo "BUILD_NUMBER=${{ env.BUILD_NUMBER }}" > .env
            echo "MYSQL_ROOT_PASSWORD=${{ env.MYSQL_ROOT_PASSWORD }}" >> .env
            echo "MYSQL_DATABASE=${{ env.MYSQL_DATABASE }}" >> .env
            echo "MYSQL_USER=${{ env.MYSQL_USER }}" >> .env
            echo "MYSQL_PASSWORD=${{ env.MYSQL_PASSWORD }}" >> .env
          fi

          # ÌôòÍ≤Ω Î≥ÄÏàò Î°úÎìú
          source .env

      - name: Detect current environment and determine target
        id: detect
        run: |
          set -e

          # ÏàòÎèôÏúºÎ°ú ÌôòÍ≤ΩÏù¥ ÏßÄÏ†ïÎêú Í≤ΩÏö∞
          if [ "${{ github.event.inputs.environment }}" != "auto" ] && [ "${{ github.event.inputs.environment }}" != "" ]; then
            TARGET="${{ github.event.inputs.environment }}"
            echo "üéØ Manual target environment: $TARGET"
          else
            # ÌòÑÏû¨ Ïã§Ìñâ Ï§ëÏù∏ ÌôòÍ≤Ω ÏûêÎèô Í∞êÏßÄ
            if docker ps --format "table {{.Names}}" | grep -q "app_blue" && curl -s http://localhost:3030/health | grep -i blue; then
              CURRENT="blue"
              TARGET="green"
            elif docker ps --format "table {{.Names}}" | grep -q "app_green" && curl -s http://localhost:3030/health | grep -i green; then
              CURRENT="green"
              TARGET="blue"
            else
              # ÏïÑÎ¨¥Í≤ÉÎèÑ Ïã§Ìñâ Ï§ëÏù¥ÏßÄ ÏïäÍ±∞ÎÇò Í∞êÏßÄÌï† Ïàò ÏóÜÏúºÎ©¥ blueÎ°ú ÏãúÏûë
              CURRENT="none"
              TARGET="blue"
            fi
            echo "üîç Auto-detected - Current: $CURRENT ‚Üí Target: $TARGET"
          fi

          echo "current=${CURRENT:-none}" >> $GITHUB_OUTPUT
          echo "target=$TARGET" >> $GITHUB_OUTPUT

      - name: Build Docker image
        run: |
          TARGET_ENV=${{ steps.detect.outputs.target }}
          echo "üèóÔ∏è  Building Docker image: myapp:$TARGET_ENV"
          docker build -t myapp:$TARGET_ENV .

      - name: Pre-deployment health check
        run: |
          echo "üè• Pre-deployment system health check"

          # Docker ÏÉÅÌÉú ÌôïÏù∏
          docker system df

          # ÎîîÏä§ÌÅ¨ Í≥µÍ∞Ñ ÌôïÏù∏
          df -h

          # Í∏∞Ï°¥ NginxÍ∞Ä Ïã§Ìñâ Ï§ëÏù∏ÏßÄ ÌôïÏù∏
          if ! docker ps | grep -q "nginx_lb"; then
            echo "üîß Starting Nginx load balancer"
            docker-compose up -d nginx
            sleep 5
          fi

      - name: Setup MySQL replication (if needed)
        run: |
          TARGET_ENV=${{ steps.detect.outputs.target }}
          CURRENT_ENV=${{ steps.detect.outputs.current }}

          if [ "$CURRENT_ENV" != "none" ] && [ "$TARGET_ENV" = "green" ]; then
            echo "üîÑ Setting up MySQL replication for Green environment"

            # Green MySQL ÏãúÏûë
            docker-compose up -d mysql_green
            sleep 10

            # Î≥µÏ†ú ÏÑ§Ï†ï Ïã§Ìñâ
            chmod +x scripts/setup_replication.sh
            ./scripts/setup_replication.sh || echo "‚ö†Ô∏è  Replication setup failed, continuing with deployment"
          fi

      - name: Deploy new environment
        id: deploy
        run: |
          set -e
          TARGET_ENV=${{ steps.detect.outputs.target }}
          CURRENT_ENV=${{ steps.detect.outputs.current }}

          echo "üöÄ Deploying to $TARGET_ENV environment"

          # ÌôòÍ≤ΩÎ≥Ñ Î∞∞Ìè¨
          export BUILD_NUMBER=${{ env.BUILD_NUMBER }}
          export MYSQL_ROOT_PASSWORD=${{ env.MYSQL_ROOT_PASSWORD }}
          export MYSQL_USER=${{ env.MYSQL_USER }}
          export MYSQL_PASSWORD=${{ env.MYSQL_PASSWORD }}

          if [ "$TARGET_ENV" = "green" ]; then
            docker-compose up -d app_green mysql_green
          else
            docker-compose up -d app_blue mysql_blue
          fi

      - name: Wait for application readiness
        timeout-minutes: 10
        run: |
          TARGET_ENV=${{ steps.detect.outputs.target }}
          echo "‚è≥ Waiting for $TARGET_ENV environment to be ready..."

          MAX_ATTEMPTS=30
          ATTEMPT=0

          while [ $ATTEMPT -lt $MAX_ATTEMPTS ]; do
            ATTEMPT=$((ATTEMPT + 1))

            if docker exec app_$TARGET_ENV curl -s -f http://localhost:8080/health >/dev/null 2>&1; then
              echo "‚úÖ $TARGET_ENV environment is healthy!"

              # Ï∂îÍ∞Ä Í≤ÄÏ¶ù
              HEALTH_RESPONSE=$(docker exec app_$TARGET_ENV curl -s http://localhost:8080/health)
              VERSION_RESPONSE=$(docker exec app_$TARGET_ENV curl -s http://localhost:8080/version)

              echo "Health: $HEALTH_RESPONSE"
              echo "Version: $VERSION_RESPONSE"
              break
            fi

            echo "Attempt $ATTEMPT/$MAX_ATTEMPTS: $TARGET_ENV not ready yet..."
            sleep 10
          done

          if [ $ATTEMPT -eq $MAX_ATTEMPTS ]; then
            echo "‚ùå $TARGET_ENV environment failed to become ready"
            exit 1
          fi

      - name: Switch traffic using deployment scripts
        run: |
          TARGET_ENV=${{ steps.detect.outputs.target }}

          echo "üîÑ Switching traffic to $TARGET_ENV using deployment scripts"

          # Î∞∞Ìè¨ Ïä§ÌÅ¨Î¶ΩÌä∏ Ïã§Ìñâ Í∂åÌïú Î∂ÄÏó¨
          chmod +x scripts/*.sh

          # ÌôòÍ≤ΩÏóê Îî∞Î•∏ Ïä§ÌÅ¨Î¶ΩÌä∏ Ïã§Ìñâ
          if [ "$TARGET_ENV" = "green" ]; then
            ./scripts/switch_to_green.sh
          else
            ./scripts/switch_to_blue.sh
          fi

      - name: Post-deployment verification
        id: verify
        run: |
          TARGET_ENV=${{ steps.detect.outputs.target }}

          echo "üîç Post-deployment verification"

          # Ïû†Ïãú ÎåÄÍ∏∞
          sleep 5

          # Ïô∏Î∂ÄÏóêÏÑú Ï†ëÍ∑º Í∞ÄÎä•Ìïú ÏóîÎìúÌè¨Ïù∏Ìä∏ ÌÖåÏä§Ìä∏
          MAX_RETRIES=10
          RETRY=0

          while [ $RETRY -lt $MAX_RETRIES ]; do
            RETRY=$((RETRY + 1))

            HEALTH_RESPONSE=$(curl -s http://localhost:3030/health || echo "FAILED")
            VERSION_RESPONSE=$(curl -s http://localhost:3030/version || echo "FAILED")

            if echo "$HEALTH_RESPONSE" | grep -i "$TARGET_ENV" && [ "$HEALTH_RESPONSE" != "FAILED" ]; then
              echo "‚úÖ Verification successful!"
              echo "Health: $HEALTH_RESPONSE"
              echo "Version: $VERSION_RESPONSE"
              echo "success=true" >> $GITHUB_OUTPUT
              break
            fi

            echo "Retry $RETRY/$MAX_RETRIES: Verification failed, retrying..."
            sleep 3
          done

          if [ $RETRY -eq $MAX_RETRIES ]; then
            echo "‚ùå Post-deployment verification failed"
            echo "Health response: $HEALTH_RESPONSE"
            echo "Version response: $VERSION_RESPONSE"
            echo "success=false" >> $GITHUB_OUTPUT
            exit 1
          fi

      - name: Cleanup old environment
        if: steps.verify.outputs.success == 'true'
        run: |
          TARGET_ENV=${{ steps.detect.outputs.target }}
          CURRENT_ENV=${{ steps.detect.outputs.current }}

          if [ "$CURRENT_ENV" != "none" ] && [ "$CURRENT_ENV" != "$TARGET_ENV" ]; then
            echo "üßπ Cleaning up old environment: $CURRENT_ENV"

            # Ïû†Ïãú ÎåÄÍ∏∞ ÌõÑ Ï†ïÎ¶¨
            sleep 10
            docker-compose stop app_$CURRENT_ENV mysql_$CURRENT_ENV || echo "‚ö†Ô∏è  Cleanup warning: containers may have already been stopped"

            echo "‚úÖ Cleanup completed"
          else
            echo "‚ÑπÔ∏è  No cleanup needed"
          fi

      - name: Set deployment result
        id: deploy_result
        run: |
          if [ "${{ steps.verify.outputs.success }}" == "true" ]; then
            echo "success=true" >> $GITHUB_OUTPUT
          else
            echo "success=false" >> $GITHUB_OUTPUT
          fi

  integration-test:
    name: üß™ Integration Tests
    runs-on: self-hosted
    needs: deploy
    if: needs.deploy.outputs.deploy_success == 'true'

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Run integration tests
        run: |
          echo "üß™ Running integration tests"

          # ÌÜµÌï© ÌÖåÏä§Ìä∏ Ïä§ÌÅ¨Î¶ΩÌä∏ Ïã§Ìñâ
          chmod +x scripts/test_deployment.sh
          ./scripts/test_deployment.sh

      - name: Performance smoke test
        run: |
          echo "‚ö° Running performance smoke test"

          # Í∞ÑÎã®Ìïú Î∂ÄÌïò ÌÖåÏä§Ìä∏
          for i in {1..10}; do
            curl -s http://localhost:3030/health >/dev/null
            curl -s http://localhost:3030/version >/dev/null
            sleep 0.1
          done

          echo "‚úÖ Performance smoke test completed"

  rollback:
    name: üîÑ Rollback (if needed)
    runs-on: self-hosted
    needs: [ deploy, integration-test ]
    if: failure() && needs.deploy.outputs.current_env != 'none'

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Execute rollback
        run: |
          CURRENT_ENV="${{ needs.deploy.outputs.current_env }}"

          if [ "$CURRENT_ENV" != "none" ]; then
            echo "üîÑ Rolling back to $CURRENT_ENV environment"

            chmod +x scripts/*.sh

            if [ "$CURRENT_ENV" = "blue" ]; then
              ./scripts/switch_to_blue.sh
            else
              ./scripts/switch_to_green.sh
            fi

            echo "‚úÖ Rollback completed"
          else
            echo "‚ö†Ô∏è  No previous environment to rollback to"
          fi

      - name: Verify rollback
        run: |
          CURRENT_ENV="${{ needs.deploy.outputs.current_env }}"

          if [ "$CURRENT_ENV" != "none" ]; then
            sleep 5
            HEALTH_RESPONSE=$(curl -s http://localhost:3030/health)

            if echo "$HEALTH_RESPONSE" | grep -i "$CURRENT_ENV"; then
              echo "‚úÖ Rollback verification successful: $HEALTH_RESPONSE"
            else
              echo "‚ùå Rollback verification failed: $HEALTH_RESPONSE"
              exit 1
            fi
          fi

  notify:
    name: üì¢ Notify Results
    runs-on: self-hosted
    needs: [ deploy, integration-test ]
    if: always()

    steps:
      - name: Deployment Summary
        run: |
          echo "üéØ Deployment Summary"
          echo "===================="
          echo "Repository: ${{ github.repository }}"
          echo "Branch: ${{ github.ref_name }}"
          echo "Commit: ${{ github.sha }}"
          echo "Build Number: ${{ env.BUILD_NUMBER }}"
          echo "Current Environment: ${{ needs.deploy.outputs.current_env }}"
          echo "Target Environment: ${{ needs.deploy.outputs.target_env }}"
          echo "Deploy Success: ${{ needs.deploy.outputs.deploy_success }}"
          echo "Integration Tests: ${{ needs.integration-test.result }}"
          echo ""

          if [ "${{ needs.deploy.outputs.deploy_success }}" == "true" ] && [ "${{ needs.integration-test.result }}" == "success" ]; then
            echo "üéâ Deployment completed successfully!"
          else
            echo "‚ùå Deployment encountered issues"
          fi
